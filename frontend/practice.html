<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StemScribe - Practice Mode</title>
    <link href="https://fonts.googleapis.com/css2?family=Righteous&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- OpenSheetMusicDisplay for MusicXML rendering -->
    <script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.8.6/build/opensheetmusicdisplay.min.js"></script>

    <!-- AlphaTab for Guitar Pro files -->
    <script src="https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.3.1/dist/alphaTab.min.js"></script>

    <!-- PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg2pdf.js/2.2.4/svg2pdf.umd.min.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-deep: #0d0d12;
            --bg-dark: #13131a;
            --bg-card: #1a1a24;
            --orange: #ff7b54;
            --pink: #ff6b9d;
            --purple: #c678dd;
            --blue: #61afef;
            --teal: #56b6c2;
            --yellow: #e5c07b;
            --green: #98c379;
            --text: #e8e4df;
            --text-dim: #7a7a85;
            --border: #2a2a35;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-deep);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .logo-text {
            font-family: 'Righteous', cursive;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--orange), var(--pink));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .song-info { text-align: center; }
        .song-title { font-family: 'Righteous', cursive; font-size: 1.1rem; }
        .song-artist { font-size: 0.8rem; color: var(--text-dim); }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-btn {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: 'Space Grotesk', sans-serif;
            transition: all 0.2s;
            text-decoration: none;
        }

        .header-btn:hover {
            border-color: var(--orange);
            color: var(--orange);
        }

        .header-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* ‚îÄ‚îÄ Main Layout ‚îÄ‚îÄ */
        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ */
        .sidebar {
            width: 260px;
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        /* Transport */
        .transport {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .transport-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .play-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--orange), var(--pink));
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: white;
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .play-btn:hover { transform: scale(1.1); }

        .time-display {
            font-family: monospace;
            font-size: 1rem;
            color: var(--text-dim);
        }

        .timeline {
            width: 100%;
            height: 5px;
            background: rgba(255,255,255,0.08);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .timeline-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--orange), var(--pink));
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Tempo */
        .tempo {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
        }

        .tempo-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 0.4rem;
        }

        .tempo-val { color: var(--yellow); font-weight: 600; }

        .tempo-slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 0.5rem;
        }

        .tempo-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--yellow);
            border-radius: 50%;
            cursor: pointer;
        }

        .tempo-presets {
            display: flex;
            gap: 0.4rem;
        }

        .tempo-preset {
            flex: 1;
            padding: 0.3rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text-dim);
            font-size: 0.7rem;
            cursor: pointer;
            font-family: 'Space Grotesk', sans-serif;
        }

        .tempo-preset:hover, .tempo-preset.active {
            border-color: var(--yellow);
            color: var(--yellow);
        }

        /* Stem Channels */
        .stems {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .stems-title {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            padding: 0.25rem 0.5rem;
            margin-bottom: 0.25rem;
        }

        .stem-ch {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.35rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stem-ch.muted { opacity: 0.3; }

        .stem-icon { font-size: 1.2rem; }
        .stem-name { font-size: 0.8rem; font-weight: 600; text-transform: capitalize; flex: 1; }

        .stem-vol {
            width: 50px;
            height: 3px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 2px;
        }

        .stem-vol::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: var(--teal);
            border-radius: 50%;
            cursor: pointer;
        }

        .mix-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 0.65rem;
            font-weight: 700;
            font-family: 'Space Grotesk', sans-serif;
        }

        .m-btn { background: var(--bg-card); color: var(--text-dim); }
        .m-btn.active { background: #e74c3c; color: white; }
        .s-btn { background: var(--bg-card); color: var(--text-dim); }
        .s-btn.active { background: var(--yellow); color: var(--bg-dark); }

        /* Shortcuts hint */
        .shortcuts-hint {
            padding: 0.5rem 0.75rem;
            border-top: 1px solid var(--border);
            font-size: 0.65rem;
            color: var(--text-dim);
            line-height: 1.5;
        }

        .shortcuts-hint kbd {
            background: var(--bg-dark);
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.6rem;
        }

        /* ‚îÄ‚îÄ Notation Area ‚îÄ‚îÄ */
        .notation-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Stem selector tabs */
        .stem-tabs {
            display: flex;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 0 1rem;
            flex-shrink: 0;
        }

        .stem-tab {
            padding: 0.6rem 1.25rem;
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.85rem;
            transition: all 0.15s;
        }

        .stem-tab:hover { color: var(--text); }

        .stem-tab.active {
            color: var(--orange);
            border-bottom-color: var(--orange);
        }

        /* Notation display */
        .notation-display {
            flex: 1;
            overflow: auto;
            background: var(--bg-dark);
            position: relative;
        }

        /* OSMD (white background for sheet music) */
        #osmd-container {
            background: #ffffff !important;
            min-height: 100%;
        }

        #osmd-container svg {
            background: #ffffff !important;
        }

        /* AlphaTab dark theme */
        #alphaTab {
            width: 100%;
            min-height: 100%;
        }

        #alphaTab .at-surface text,
        #alphaTab svg text { fill: #e8e4df !important; }

        .at-cursor-bar { background: rgba(255, 123, 84, 0.2) !important; }
        .at-cursor-beat {
            background: rgba(255, 107, 157, 0.4) !important;
            box-shadow: 0 0 8px rgba(255, 107, 157, 0.4);
        }
        .at-highlight * { fill: var(--orange) !important; }

        /* Custom OSMD cursor */
        #osmd-custom-cursor {
            position: absolute !important;
            width: 4px !important;
            background: linear-gradient(180deg, #ff3300, #ff6600) !important;
            border-radius: 2px !important;
            box-shadow: 0 0 20px rgba(255, 50, 0, 0.8) !important;
            z-index: 9999 !important;
            pointer-events: none !important;
        }

        /* Loading state */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: var(--bg-deep);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            z-index: 100;
        }

        .loading-overlay.hidden { display: none; }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--orange);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 2rem;
        }

        .empty-state h2 {
            font-family: 'Righteous', cursive;
            font-size: 1.4rem;
            margin-bottom: 0.75rem;
        }

        .empty-state p {
            color: var(--text-dim);
            margin-bottom: 1rem;
        }

        .cta-btn {
            display: inline-block;
            background: linear-gradient(135deg, var(--orange), var(--pink));
            border: none;
            padding: 0.6rem 1.25rem;
            border-radius: 8px;
            color: white;
            font-family: 'Righteous', cursive;
            font-size: 0.95rem;
            cursor: pointer;
            text-decoration: none;
        }

        .drop-zone {
            margin-top: 1.5rem;
            border: 2px dashed var(--border);
            border-radius: 10px;
            padding: 1.5rem 2rem;
            cursor: pointer;
            position: relative;
            transition: border-color 0.2s;
        }

        .drop-zone:hover { border-color: var(--purple); }

        .drop-zone input {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            color: var(--text);
            padding: 8px 18px;
            border-radius: 8px;
            border: 1px solid var(--orange);
            font-size: 0.85rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        /* Print styles */
        @media print {
            .header, .sidebar, .stem-tabs, .loading-overlay, #osmd-custom-cursor { display: none !important; }
            body { background: white !important; color: black !important; }
            .main { display: block !important; height: auto !important; }
            .notation-area { overflow: visible !important; }
            .notation-display { overflow: visible !important; max-height: none !important; background: white !important; }
            #osmd-container { max-height: none !important; overflow: visible !important; }
            #osmd-container svg, #alphaTab { background: white !important; page-break-inside: avoid; }
        }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="header">
        <div class="logo">
            <span style="font-size: 1.3rem;">‚ú¶</span>
            <span class="logo-text">StemScribe</span>
        </div>

        <div class="song-info">
            <div class="song-title" id="songTitle">Practice Mode</div>
            <div class="song-artist" id="songArtist">Load a track to begin</div>
        </div>

        <div class="header-actions">
            <button class="header-btn" id="exportPDF" style="display:none;" title="Export as PDF">üìÑ PDF</button>
            <button class="header-btn" id="printNotation" style="display:none;" title="Print">üñ® Print</button>
            <button class="header-btn" id="downloadMusicXML" style="display:none;" title="Download MusicXML">üìú XML</button>
            <button class="header-btn" id="downloadGP" style="display:none;" title="Download Guitar Pro">üé∏ GP</button>
            <a href="index.html" class="header-btn">‚Üê Back</a>
        </div>
    </header>

    <!-- Main -->
    <div class="main">

        <!-- Sidebar: Transport + Mixer -->
        <aside class="sidebar">
            <div class="transport">
                <div class="transport-row">
                    <button class="play-btn" id="playBtn" title="Play/Pause">‚ñ∂</button>
                    <div class="time-display">
                        <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
                    </div>
                </div>
                <div class="timeline" id="timeline">
                    <div class="timeline-fill" id="timelineFill"></div>
                </div>
            </div>

            <div class="tempo">
                <div class="tempo-header">
                    <span>Tempo</span>
                    <span class="tempo-val" id="tempoValue">100%</span>
                </div>
                <input type="range" class="tempo-slider" id="tempoSlider" min="25" max="150" value="100">
                <div class="tempo-presets">
                    <button class="tempo-preset" data-tempo="50">50%</button>
                    <button class="tempo-preset" data-tempo="75">75%</button>
                    <button class="tempo-preset active" data-tempo="100">100%</button>
                </div>
            </div>

            <div class="stems-title">üéõ Stem Mixer</div>
            <div class="stems" id="stemChannels">
                <!-- Populated by JS -->
            </div>

            <div class="shortcuts-hint">
                <kbd>Space</kbd> Play &nbsp; <kbd>‚Üê‚Üí</kbd> Seek &nbsp; <kbd>‚Üë‚Üì</kbd> Tempo<br>
                <kbd>[</kbd><kbd>]</kbd> Loop A/B &nbsp; <kbd>L</kbd> Loop &nbsp; <kbd>R</kbd> Reset
            </div>
        </aside>

        <!-- Notation -->
        <div class="notation-area">
            <div class="stem-tabs" id="stemTabs">
                <!-- Populated by JS when job loads -->
            </div>

            <div class="notation-display">
                <div class="loading-overlay hidden" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div id="loadingText">Loading notation...</div>
                </div>

                <div id="alphaTab">
                    <div class="empty-state" id="emptyState">
                        <h2>üéµ Practice Mode</h2>
                        <p>Process a song to get stems and notation, or load a file directly.</p>
                        <a href="index.html" class="cta-btn">‚ú¶ Separate a Track</a>
                        <div class="drop-zone">
                            <input type="file" id="fileInput" accept=".gp,.gp3,.gp4,.gp5,.gpx,.xml,.musicxml,.mid,.midi">
                            <div style="font-size: 1.5rem; margin-bottom: 0.4rem;">üìÅ</div>
                            <div style="font-size: 0.9rem;">Drop Guitar Pro / MusicXML / MIDI</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <div class="toast" id="toast"></div>

    <script>
        const API_BASE = 'http://localhost:5555/api';

        // ‚îÄ‚îÄ State ‚îÄ‚îÄ
        let currentJob = null;
        let stemAudios = {};
        let isPlaying = false;
        let duration = 0;
        let soloedStems = new Set();
        let alphaTabApi = null;
        let osmd = null;
        let osmdCursor = null;
        let osmdMeasureTimes = [];
        let osmdTempo = 120;
        let playbackRate = 1.0;
        let notationDuration = 0;
        let isSyncing = false;
        let currentRenderer = null; // 'osmd' or 'alphatab'
        let currentNotationStem = null;
        let currentNotationFileType = null;
        let loopStart = 0, loopEnd = 0, loopEnabled = false;
        let osmdCursorPositions = [];
        let lastCursorIndex = -1;

        const stemConfig = {
            vocals:   { icon: 'üéôÔ∏è', color: '#ff6b9d' },
            vocals_lead: { icon: 'üéôÔ∏è', color: '#ff6b9d' },
            vocals_backing: { icon: 'üé∂', color: '#c678dd' },
            drums:    { icon: 'ü•Å', color: '#e5c07b' },
            bass:     { icon: 'üîä', color: '#ff7b54' },
            guitar:   { icon: 'üé∏', color: '#61afef' },
            piano:    { icon: 'üéπ', color: '#98c379' },
            other:    { icon: 'üéª', color: '#c678dd' }
        };

        // ‚îÄ‚îÄ Init ‚îÄ‚îÄ
        document.addEventListener('DOMContentLoaded', async () => {
            const params = new URLSearchParams(window.location.search);
            const jobId = params.get('job');
            const stemParam = params.get('stem');

            if (jobId) await loadJob(jobId, stemParam);
            setupEventListeners();
        });

        // ‚îÄ‚îÄ Event Listeners ‚îÄ‚îÄ
        function setupEventListeners() {
            document.getElementById('playBtn').addEventListener('click', togglePlayback);
            document.getElementById('timeline').addEventListener('click', seekTo);

            document.getElementById('tempoSlider').addEventListener('input', (e) => {
                const v = e.target.value;
                document.getElementById('tempoValue').textContent = v + '%';
                playbackRate = v / 100;
                updatePlaybackRate();
                document.querySelectorAll('.tempo-preset').forEach(b =>
                    b.classList.toggle('active', b.dataset.tempo == v));
            });

            document.querySelectorAll('.tempo-preset').forEach(btn => {
                btn.addEventListener('click', () => {
                    const t = btn.dataset.tempo;
                    document.getElementById('tempoSlider').value = t;
                    document.getElementById('tempoValue').textContent = t + '%';
                    playbackRate = t / 100;
                    updatePlaybackRate();
                    document.querySelectorAll('.tempo-preset').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });

            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            document.addEventListener('keydown', handleKeys);
            setInterval(updateTimeline, 100);
        }

        // ‚îÄ‚îÄ Keyboard Shortcuts ‚îÄ‚îÄ
        function handleKeys(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            switch(e.code) {
                case 'Space': e.preventDefault(); togglePlayback(); break;
                case 'ArrowLeft': e.preventDefault(); seekRelative(-5); break;
                case 'ArrowRight': e.preventDefault(); seekRelative(5); break;
                case 'ArrowUp': e.preventDefault(); adjustTempo(5); break;
                case 'ArrowDown': e.preventDefault(); adjustTempo(-5); break;
                case 'BracketLeft': e.preventDefault(); setLoopPoint('start'); break;
                case 'BracketRight': e.preventDefault(); setLoopPoint('end'); break;
                case 'KeyL': e.preventDefault(); toggleLoop(); break;
                case 'KeyR': e.preventDefault(); seekToTime(0); break;
            }
        }

        // ‚îÄ‚îÄ Load Job ‚îÄ‚îÄ
        async function loadJob(jobId, requestedStem = null) {
            try {
                const response = await fetch(`${API_BASE}/status/${jobId}`);
                const job = await response.json();
                if (job.error) { alert('Job not found'); return; }

                currentJob = job;
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('songTitle').textContent = job.metadata?.title || 'Unknown Track';
                document.getElementById('songArtist').textContent = job.metadata?.artist || '';

                loadStemAudio(job);
                buildStemTabs(job, requestedStem);

                // Load initial notation
                const hasXml = job.musicxml_files && Object.keys(job.musicxml_files).length > 0;
                const hasGP = job.gp_files && Object.keys(job.gp_files).length > 0;
                if (hasXml || hasGP) {
                    const stemToLoad = requestedStem || 'guitar';
                    loadNotationForStem(stemToLoad);
                }
            } catch (error) {
                console.error('Failed to load job:', error);
            }
        }

        // ‚îÄ‚îÄ Build stem selector tabs dynamically ‚îÄ‚îÄ
        function buildStemTabs(job, activeStem) {
            const container = document.getElementById('stemTabs');
            container.innerHTML = '';

            // Collect all stems that have notation
            const notationStems = new Set();
            if (job.musicxml_files) Object.keys(job.musicxml_files).forEach(k => {
                const base = k.replace(/_enhanced$|_basic_pitch$/, '');
                notationStems.add(base);
            });
            if (job.gp_files) Object.keys(job.gp_files).forEach(k => {
                const base = k.replace(/_enhanced$|_basic_pitch$/, '');
                notationStems.add(base);
            });

            const order = ['guitar', 'bass', 'piano', 'drums', 'vocals'];
            const sorted = [...notationStems].sort((a, b) =>
                (order.indexOf(a) === -1 ? 99 : order.indexOf(a)) -
                (order.indexOf(b) === -1 ? 99 : order.indexOf(b))
            );

            const active = activeStem || sorted[0] || 'guitar';

            sorted.forEach(stem => {
                const btn = document.createElement('button');
                btn.className = 'stem-tab' + (stem === active ? ' active' : '');
                btn.dataset.stem = stem;
                const icon = stemConfig[stem]?.icon || 'üéµ';
                btn.textContent = `${icon} ${stem.charAt(0).toUpperCase() + stem.slice(1)}`;
                btn.addEventListener('click', () => {
                    container.querySelectorAll('.stem-tab').forEach(t => t.classList.remove('active'));
                    btn.classList.add('active');
                    loadNotationForStem(stem);
                });
                container.appendChild(btn);
            });
        }

        // ‚îÄ‚îÄ Load Stem Audio + Mixer ‚îÄ‚îÄ
        function loadStemAudio(job) {
            const container = document.getElementById('stemChannels');
            container.innerHTML = '';
            stemAudios = {};

            const stemOrder = ['vocals', 'vocals_lead', 'vocals_backing', 'guitar', 'bass', 'drums', 'piano', 'other'];
            const sorted = Object.entries(job.stems).sort((a, b) =>
                (stemOrder.indexOf(a[0]) === -1 ? 99 : stemOrder.indexOf(a[0])) -
                (stemOrder.indexOf(b[0]) === -1 ? 99 : stemOrder.indexOf(b[0]))
            );

            sorted.forEach(([name, path]) => {
                const clean = name.replace(/^Other_/i, '').toLowerCase();
                const display = clean.replace(/_/g, ' ');
                const cfg = stemConfig[clean] || { icon: 'üéµ', color: '#888' };

                const ch = document.createElement('div');
                ch.className = 'stem-ch';
                ch.id = `channel-${clean}`;
                ch.innerHTML = `
                    <span class="stem-icon">${cfg.icon}</span>
                    <span class="stem-name">${display}</span>
                    <input type="range" class="stem-vol" data-stem="${clean}" min="0" max="100" value="80">
                    <button class="mix-btn m-btn" data-stem="${clean}">M</button>
                    <button class="mix-btn s-btn" data-stem="${clean}">S</button>
                    <audio id="audio-${clean}" src="${API_BASE}/download/${job.job_id}/stem/${name}" preload="auto"></audio>
                `;
                container.appendChild(ch);

                const audio = ch.querySelector(`#audio-${clean}`);
                stemAudios[clean] = { audio, muted: false, volume: 0.8 };
                audio.volume = 0.8;
                audio.addEventListener('loadedmetadata', () => {
                    if (duration === 0) {
                        duration = audio.duration;
                        document.getElementById('totalTime').textContent = formatTime(duration);
                    }
                });
            });

            setupMixerControls();
        }

        function setupMixerControls() {
            document.querySelectorAll('.m-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const s = btn.dataset.stem;
                    stemAudios[s].muted = !stemAudios[s].muted;
                    btn.classList.toggle('active', stemAudios[s].muted);
                    document.getElementById(`channel-${s}`)?.classList.toggle('muted', stemAudios[s].muted);
                    updateStemVolumes();
                });
            });

            document.querySelectorAll('.s-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const s = btn.dataset.stem;
                    if (soloedStems.has(s)) { soloedStems.delete(s); btn.classList.remove('active'); }
                    else { soloedStems.add(s); btn.classList.add('active'); }
                    updateStemVolumes();
                });
            });

            document.querySelectorAll('.stem-vol').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const s = slider.dataset.stem;
                    stemAudios[s].volume = e.target.value / 100;
                    updateStemVolumes();
                });
            });
        }

        // ‚îÄ‚îÄ Playback ‚îÄ‚îÄ
        function updateStemVolumes() {
            const hasSolo = soloedStems.size > 0;
            Object.entries(stemAudios).forEach(([name, d]) => {
                let vol = d.volume;
                if (hasSolo && !soloedStems.has(name)) vol = 0;
                if (d.muted) vol = 0;
                d.audio.volume = vol;
            });
        }

        function updatePlaybackRate() {
            Object.values(stemAudios).forEach(s => s.audio.playbackRate = playbackRate);
        }

        function togglePlayback() {
            const btn = document.getElementById('playBtn');
            if (isPlaying) {
                Object.values(stemAudios).forEach(s => s.audio.pause());
                btn.textContent = '‚ñ∂';
                isPlaying = false;
            } else {
                const t = Object.values(stemAudios)[0]?.audio.currentTime || 0;
                Object.values(stemAudios).forEach(s => {
                    s.audio.currentTime = t;
                    s.audio.playbackRate = playbackRate;
                    s.audio.play();
                });
                btn.textContent = '‚è∏';
                isPlaying = true;
            }
        }

        function seekTo(e) {
            const rect = document.getElementById('timeline').getBoundingClientRect();
            const pct = (e.clientX - rect.left) / rect.width;
            const t = pct * duration;
            seekToTime(t);
        }

        function seekToTime(t) {
            Object.values(stemAudios).forEach(s => s.audio.currentTime = t);
            lastCursorIndex = -1;
            syncNotationCursor(t);
        }

        function seekRelative(sec) {
            const a = Object.values(stemAudios)[0];
            if (!a) return;
            seekToTime(Math.max(0, Math.min(duration, a.audio.currentTime + sec)));
        }

        function adjustTempo(delta) {
            const slider = document.getElementById('tempoSlider');
            const v = Math.max(25, Math.min(150, parseInt(slider.value) + delta));
            slider.value = v;
            document.getElementById('tempoValue').textContent = v + '%';
            playbackRate = v / 100;
            updatePlaybackRate();
            document.querySelectorAll('.tempo-preset').forEach(b =>
                b.classList.toggle('active', b.dataset.tempo == v));
            showToast(`Tempo: ${v}%`);
        }

        function setLoopPoint(which) {
            const a = Object.values(stemAudios)[0];
            if (!a) return;
            if (which === 'start') { loopStart = a.audio.currentTime; showToast(`Loop A: ${formatTime(loopStart)}`); }
            else { loopEnd = a.audio.currentTime; if (loopEnd > loopStart) loopEnabled = true; showToast(`Loop B: ${formatTime(loopEnd)}`); }
        }

        function toggleLoop() {
            if (loopStart < loopEnd) {
                loopEnabled = !loopEnabled;
                showToast(loopEnabled ? `Loop: ${formatTime(loopStart)}-${formatTime(loopEnd)}` : 'Loop OFF');
            } else { showToast('Set loop with [ and ]'); }
        }

        function updateTimeline() {
            if (!Object.keys(stemAudios).length) return;
            const a = Object.values(stemAudios)[0].audio;
            const pct = (a.currentTime / duration) * 100 || 0;
            document.getElementById('timelineFill').style.width = `${pct}%`;
            document.getElementById('currentTime').textContent = formatTime(a.currentTime);
            syncNotationCursor(a.currentTime);

            if (loopEnabled && loopStart < loopEnd && a.currentTime >= loopEnd && isPlaying) {
                Object.values(stemAudios).forEach(s => s.audio.currentTime = loopStart);
                lastCursorIndex = -1;
            } else if (a.currentTime >= duration - 0.1 && isPlaying) {
                Object.values(stemAudios).forEach(s => s.audio.currentTime = 0);
            }
        }

        function formatTime(s) {
            const m = Math.floor(s / 60);
            const sec = Math.floor(s % 60);
            return `${m}:${sec.toString().padStart(2, '0')}`;
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.style.opacity = '1';
            clearTimeout(t._tid);
            t._tid = setTimeout(() => t.style.opacity = '0', 1500);
        }

        // ‚îÄ‚îÄ Load Notation ‚îÄ‚îÄ
        async function loadNotationForStem(stemType) {
            if (!currentJob) return;

            const stemMapping = { 'tab': 'guitar', 'guitar': 'guitar', 'bass': 'bass', 'piano': 'piano', 'drums': 'drums', 'vocals': 'vocals' };
            const actualStem = stemMapping[stemType] || stemType;

            function findMatch(dict, stem) {
                if (!dict) return null;
                if (dict[stem]) return stem;
                const keys = Object.keys(dict);
                let enhanced = null, basic = null;
                for (const k of keys) {
                    if (k.startsWith(stem + '_') || k === stem) {
                        if (k.includes('enhanced')) enhanced = k;
                        else if (!basic) basic = k;
                    }
                }
                return enhanced || basic || null;
            }

            const gpMatch = findMatch(currentJob.gp_files, actualStem);
            const xmlMatch = findMatch(currentJob.musicxml_files, actualStem);

            const isTab = actualStem.includes('guitar') || actualStem.includes('bass');
            let fileType = null, targetStem = null;

            if (isTab) {
                if (gpMatch) { fileType = 'gp'; targetStem = gpMatch; }
                else if (xmlMatch) { fileType = 'musicxml'; targetStem = xmlMatch; }
            } else {
                if (xmlMatch) { fileType = 'musicxml'; targetStem = xmlMatch; }
                else if (gpMatch) { fileType = 'gp'; targetStem = gpMatch; }
            }

            // Fallback to any available
            if (!fileType) {
                if (currentJob.gp_files && Object.keys(currentJob.gp_files).length > 0) {
                    targetStem = Object.keys(currentJob.gp_files)[0]; fileType = 'gp';
                } else if (currentJob.musicxml_files && Object.keys(currentJob.musicxml_files).length > 0) {
                    targetStem = Object.keys(currentJob.musicxml_files)[0]; fileType = 'musicxml';
                }
            }

            if (!fileType) {
                document.getElementById('alphaTab').innerHTML = `
                    <div class="empty-state">
                        <h2>üìù No Notation</h2>
                        <p>No notation files available for "${stemType}"</p>
                    </div>`;
                return;
            }

            document.getElementById('loadingOverlay').classList.remove('hidden');

            try {
                const url = `${API_BASE}/download/${currentJob.job_id}/${fileType}/${targetStem}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Failed to fetch: ${response.statusText}`);

                const data = await response.arrayBuffer();
                if (data.byteLength === 0) throw new Error('Empty file');

                const ext = fileType === 'gp' ? 'gp5' : 'musicxml';
                const filename = `${targetStem}.${ext}`;

                if (fileType === 'musicxml') initOSMD(new Uint8Array(data), filename);
                else initAlphaTab(new Uint8Array(data), filename);

                currentNotationStem = targetStem;
                currentNotationFileType = fileType;
                setTimeout(updateExportButtons, 500);
            } catch (error) {
                console.error('Notation load failed:', error);
                document.getElementById('loadingOverlay').classList.add('hidden');
                document.getElementById('alphaTab').innerHTML = `
                    <div class="empty-state" style="color: #f77;">
                        <h2>‚ö†Ô∏è Load Failed</h2>
                        <p>${error.message}</p>
                    </div>`;
            }
        }

        // ‚îÄ‚îÄ OSMD (MusicXML Rendering) ‚îÄ‚îÄ
        async function initOSMD(data, filename) {
            const container = document.getElementById('alphaTab');
            const overlay = document.getElementById('loadingOverlay');

            function hideLoading() {
                overlay.classList.add('hidden');
                overlay.style.display = 'none';
            }

            try {
                currentRenderer = 'osmd';
                alphaTabApi = null;

                container.innerHTML = '<div id="osmd-container"></div><div id="osmd-custom-cursor" style="display:none;"></div>';
                const osmdContainer = document.getElementById('osmd-container');

                const xmlString = new TextDecoder().decode(data);

                osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdContainer, {
                    autoResize: true,
                    backend: 'svg',
                    drawTitle: false,
                    drawComposer: false,
                    drawPartNames: true,
                    drawMeasureNumbers: true,
                    followCursor: true,
                    cursorsOptions: [{ type: 0, color: '#ff7b54', alpha: 0.6, follow: true }]
                });

                await osmd.load(xmlString);
                osmd.render();

                osmdCursor = osmd.cursor;
                if (osmdCursor) {
                    osmdCursor.show();
                    osmdCursor.reset();
                }

                calculateOSMDMeasureTimes();

                const measures = osmd.sheet?.sourceMeasures?.length || 0;
                console.log(`[OSMD] ‚úÖ ${measures} measures rendered`);

                hideLoading();

                // Auto-export PDF if requested
                const autoExport = new URLSearchParams(window.location.search).get('autoExportPDF');
                if (autoExport === 'true') {
                    setTimeout(() => {
                        const pdfBtn = document.getElementById('exportPDF');
                        if (pdfBtn) { pdfBtn.style.display = 'block'; pdfBtn.click(); }
                    }, 500);
                }

            } catch (error) {
                console.error('[OSMD] Error:', error);
                hideLoading();
                container.innerHTML = `
                    <div class="empty-state" style="color: #f77;">
                        <h2>‚ö†Ô∏è Rendering Failed</h2>
                        <p>${error.message}</p>
                    </div>`;
            }
        }

        // ‚îÄ‚îÄ OSMD Cursor Sync ‚îÄ‚îÄ
        function calculateOSMDMeasureTimes() {
            osmdMeasureTimes = [];
            osmdCursorPositions = [];
            if (!osmd || !osmd.sheet) return;

            try {
                osmdTempo = osmd.sheet.defaultStartTempoInBpm || 120;
                let currentTime = 0;
                const measures = osmd.sheet.sourceMeasures;

                for (let i = 0; i < measures.length; i++) {
                    osmdMeasureTimes.push(currentTime);
                    const m = measures[i];
                    const ts = m.activeTimeSignature;
                    const beats = ts ? ts.numerator : 4;
                    const beatType = ts ? ts.denominator : 4;
                    const duration = (beats * (4 / beatType) * 60) / osmdTempo;
                    currentTime += duration;
                }

                // Build cursor positions
                if (osmdCursor) {
                    osmdCursor.reset();
                    let idx = 0;
                    while (!osmdCursor.iterator?.endReached) {
                        const m = osmdCursor.iterator?.currentMeasureIndex || 0;
                        const mTime = osmdMeasureTimes[m] || 0;
                        const mDur = (osmdMeasureTimes[m+1] || currentTime) - mTime;
                        const beat = osmdCursor.iterator?.currentBeat || 1;
                        const ts = measures[m]?.activeTimeSignature;
                        const totalBeats = ts ? ts.numerator : 4;
                        const beatFraction = Math.max(0, beat - 1) / totalBeats;
                        osmdCursorPositions.push({ time: mTime + beatFraction * mDur, index: idx });
                        osmdCursor.next();
                        idx++;
                    }
                    osmdCursor.reset();
                }
            } catch (e) { console.warn('OSMD timing calc error:', e); }
        }

        function getOSMDMeasureAtTime(t) {
            for (let i = osmdMeasureTimes.length - 1; i >= 0; i--) {
                if (t >= osmdMeasureTimes[i]) return i;
            }
            return 0;
        }

        function getOSMDCursorIndexAtTime(t) {
            if (osmdCursorPositions.length === 0) return 0;
            let lo = 0, hi = osmdCursorPositions.length - 1;
            while (lo < hi) {
                const mid = Math.ceil((lo + hi) / 2);
                if (osmdCursorPositions[mid].time <= t) lo = mid;
                else hi = mid - 1;
            }
            return osmdCursorPositions[lo].index;
        }

        function syncNotationCursor(t) {
            if (currentRenderer === 'osmd' && osmd && osmdCursor && osmdCursorPositions.length > 0) {
                if (isSyncing) return;
                isSyncing = true;
                try {
                    const target = getOSMDCursorIndexAtTime(t);
                    if (target !== lastCursorIndex) {
                        if (target === 0 || target < lastCursorIndex) {
                            osmdCursor.reset();
                            for (let i = 0; i < target && !osmdCursor.iterator?.endReached; i++) osmdCursor.next();
                        } else {
                            for (let i = 0; i < target - lastCursorIndex && !osmdCursor.iterator?.endReached; i++) osmdCursor.next();
                        }
                        osmdCursor.update();
                        lastCursorIndex = target;
                    }
                } catch (e) { console.warn('OSMD sync error:', e); }
                isSyncing = false;
            }

            if (currentRenderer === 'alphatab' && alphaTabApi?.score && notationDuration > 0) {
                if (isSyncing) return;
                isSyncing = true;
                try {
                    const scaledMs = (t / (duration || 1)) * notationDuration;
                    if (typeof alphaTabApi.timePosition !== 'undefined' && Math.abs(alphaTabApi.timePosition - scaledMs) > 100) {
                        alphaTabApi.timePosition = scaledMs;
                    }
                } catch (e) {}
                isSyncing = false;
            }
        }

        // ‚îÄ‚îÄ AlphaTab (Guitar Pro Rendering) ‚îÄ‚îÄ
        function initAlphaTab(data, filename) {
            const container = document.getElementById('alphaTab');
            container.innerHTML = '';

            currentRenderer = 'alphatab';
            osmd = null;

            try {
                alphaTabApi = new alphaTab.AlphaTabApi(container, {
                    core: { engine: 'html5', logLevel: 1 },
                    display: {
                        scale: 0.9,
                        resources: {
                            staffLineColor: '#555',
                            mainGlyphColor: '#fff',
                            scoreInfoColor: '#e8e4df',
                            secondaryGlyphColor: '#aaa',
                            barSeparatorColor: '#666'
                        }
                    },
                    notation: {
                        elements: {
                            scoreTitle: true,
                            scoreSubTitle: true,
                            guitarTuning: true,
                            trackNames: true,
                            chordDiagrams: true
                        }
                    },
                    player: {
                        enablePlayer: true,
                        enableCursor: true,
                        enableUserInteraction: true,
                        scrollMode: 1
                    }
                });

                alphaTabApi.scoreLoaded.on((score) => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                    if (!currentJob) {
                        document.getElementById('songTitle').textContent = score.title || filename;
                        document.getElementById('songArtist').textContent = score.artist || '';
                    }
                    // Calculate notation duration
                    if (score?.masterBars) {
                        try {
                            const tempo = score.tempo || 120;
                            let totalTicks = 0;
                            score.masterBars.forEach(bar => {
                                const ts = bar.timeSignature;
                                const beats = ts ? (ts.numerator * 4 / ts.denominator.value) : 4;
                                totalTicks += beats * 960;
                            });
                            notationDuration = (totalTicks / 960) * (60000 / tempo);
                        } catch (e) {}
                    }
                });

                alphaTabApi.renderFinished.on(() => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                });

                alphaTabApi.error.on((e) => {
                    console.error('AlphaTab error:', e);
                    document.getElementById('loadingOverlay').classList.add('hidden');
                    container.innerHTML = `<div class="empty-state" style="color: #f77;"><h2>‚ö†Ô∏è Render Failed</h2><p>${e.message || 'Unknown error'}</p></div>`;
                });

                alphaTabApi.load(data);

                // Timeout fallback
                setTimeout(() => {
                    const o = document.getElementById('loadingOverlay');
                    if (!o.classList.contains('hidden')) o.classList.add('hidden');
                }, 15000);

            } catch (err) {
                console.error('AlphaTab init failed:', err);
                document.getElementById('loadingOverlay').classList.add('hidden');
                container.innerHTML = `<div class="empty-state" style="color: #f77;"><h2>‚ö†Ô∏è Error</h2><p>${err.message}</p></div>`;
            }
        }

        // ‚îÄ‚îÄ File Input ‚îÄ‚îÄ
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('loadingOverlay').classList.remove('hidden');

            const reader = new FileReader();
            reader.onload = (ev) => {
                const data = new Uint8Array(ev.target.result);
                const fn = file.name.toLowerCase();
                if (fn.endsWith('.musicxml') || fn.endsWith('.xml')) initOSMD(data, file.name);
                else initAlphaTab(data, file.name);
            };
            reader.readAsArrayBuffer(file);
        }

        // ‚îÄ‚îÄ Export Buttons ‚îÄ‚îÄ
        function updateExportButtons() {
            const hasXml = currentJob?.musicxml_files && Object.keys(currentJob.musicxml_files).length > 0;
            const hasGP = currentJob?.gp_files && Object.keys(currentJob.gp_files).length > 0;
            const hasOSMD = currentRenderer === 'osmd' && osmd;

            const xmlBtn = document.getElementById('downloadMusicXML');
            const gpBtn = document.getElementById('downloadGP');
            const pdfBtn = document.getElementById('exportPDF');
            const printBtn = document.getElementById('printNotation');

            if (xmlBtn) xmlBtn.style.display = (hasXml && currentNotationStem) ? 'inline-block' : 'none';
            if (gpBtn) gpBtn.style.display = (hasGP && currentNotationStem) ? 'inline-block' : 'none';
            if (pdfBtn) pdfBtn.style.display = hasOSMD ? 'inline-block' : 'none';
            if (printBtn) printBtn.style.display = (hasOSMD || alphaTabApi?.score) ? 'inline-block' : 'none';
        }

        // MusicXML download
        document.getElementById('downloadMusicXML')?.addEventListener('click', () => {
            if (!currentJob || !currentNotationStem) return;
            const k = Object.keys(currentJob.musicxml_files || {}).find(k => k === currentNotationStem || k.startsWith(currentNotationStem + '_'));
            if (k) { const a = document.createElement('a'); a.href = `${API_BASE}/download/${currentJob.job_id}/musicxml/${k}`; a.download = `${k}.musicxml`; a.click(); }
        });

        // GP download
        document.getElementById('downloadGP')?.addEventListener('click', () => {
            if (!currentJob || !currentNotationStem) return;
            const k = Object.keys(currentJob.gp_files || {}).find(k => k === currentNotationStem || k.startsWith(currentNotationStem + '_'));
            if (k) { const a = document.createElement('a'); a.href = `${API_BASE}/download/${currentJob.job_id}/gp/${k}`; a.download = `${k}.gp5`; a.click(); }
        });

        // PDF Export
        document.getElementById('exportPDF')?.addEventListener('click', async () => {
            if (!osmd) return;
            const btn = document.getElementById('exportPDF');
            const orig = btn.textContent;
            btn.textContent = '‚è≥...';
            btn.disabled = true;

            try {
                const { jsPDF } = window.jspdf;
                const svgs = document.getElementById('osmd-container').querySelectorAll('svg');
                if (svgs.length === 0) throw new Error('No SVG notation found');

                const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'letter' });
                const pw = pdf.internal.pageSize.getWidth();
                const ph = pdf.internal.pageSize.getHeight();
                const margin = 40;

                const title = document.getElementById('songTitle')?.textContent || 'Notation';
                const artist = document.getElementById('songArtist')?.textContent || '';
                pdf.setFontSize(18);
                pdf.text(title, pw / 2, margin, { align: 'center' });
                if (artist) { pdf.setFontSize(12); pdf.text(artist, pw / 2, margin + 20, { align: 'center' }); }

                let y = margin + 45;
                for (let i = 0; i < svgs.length; i++) {
                    const svg = svgs[i];
                    const rect = svg.getBoundingClientRect();
                    if (rect.width === 0 || rect.height === 0) continue;
                    const scale = (pw - 2 * margin) / rect.width;
                    const sh = rect.height * scale;
                    if (y + sh > ph - margin && i > 0) { pdf.addPage(); y = margin; }
                    await pdf.svg(svg, { x: margin, y, width: pw - 2 * margin, height: sh });
                    y += sh + 10;
                }

                const safe = title.replace(/[^a-z0-9]/gi, '_');
                pdf.save(`${safe}_${currentNotationStem || 'notation'}.pdf`);
            } catch (err) {
                console.error('PDF export failed:', err);
                alert('PDF export failed: ' + err.message);
            } finally {
                btn.textContent = orig;
                btn.disabled = false;
            }
        });

        // Print
        document.getElementById('printNotation')?.addEventListener('click', () => window.print());

    </script>
</body>
</html>
